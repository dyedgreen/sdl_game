// Man
target_rect.x = window_w / 2 - ((GameData*)scene->data)->test_sprite->w*4 / 2 + ((GameData*)scene->data)->p_x / 0.5;
target_rect.y = window_h / 2 - ((GameData*)scene->data)->test_sprite->h*4 / 2;
target_rect.w = ((GameData*)scene->data)->test_sprite->w * 4;
target_rect.h = ((GameData*)scene->data)->test_sprite->h * 4;
// Render the texture anim
renderSprite(scene->renderer, ((GameData*)scene->data)->test_sprite, frame, &target_rect);


  // Get some input
  const Uint8 *keyboard_state = SDL_GetKeyboardState(NULL);
  if (keyboard_state[SDL_SCANCODE_RIGHT] && !keyboard_state[SDL_SCANCODE_LEFT]) {
    ((GameData*)scene->data)->p_x ++;
    ((GameData*)scene->data)->test_sprite->flip = SDL_FLIP_NONE;
    ((GameData*)scene->data)->test_sprite->speed = 10;
  } else if (keyboard_state[SDL_SCANCODE_LEFT] && !keyboard_state[SDL_SCANCODE_RIGHT]) {
    ((GameData*)scene->data)->p_x --;
    ((GameData*)scene->data)->test_sprite->flip = SDL_FLIP_HORIZONTAL;
    ((GameData*)scene->data)->test_sprite->speed = 10;
  } else {
    ((GameData*)scene->data)->test_sprite->speed = 0;
  }


***map.c***
  #import "map.h"

  // Generate a map (returns an array of types)
  void generateMap(TileType* map_prototype[], int width, int height, int pad_w, int pad_h) {
    // TODO: Right now, just fill the map_prototype with random data
    for (int i = 0; i < (width + 2*pad_w) + (height + 2*pad_h); i++) {
      (*map_prototype)[i] = (TileType)(rand() % 33);
    }
  }

  // Create a map (TODO: REmove the whole padding thing)
  Map* createMap(SDL_Renderer* renderer, int width, int height, int pad_w, int pad_h) {
    // Generate a prototype map, that contains all the tile types of the final map
    int map_size = (width + 2*pad_w) + (height + 2*pad_h);
    TileType* map_prototype = malloc(sizeof(TileType) * map_size);
    generateMap(&map_prototype, width, height, pad_w, pad_h);
    // Allocate the tiles array
    Tile** tiles = malloc(sizeof(Tile*) * map_size);
    // Create all tiles and determine whether they are decoration
    int c_x = 0;
    int c_y = 0;
    for (int i = 0; i < map_size; i ++) {
      c_x = i % (width + 2*pad_w);
      c_y = i / (width + 2*pad_w);
      tiles[i] = createTile(map_prototype[i], rand() % 100 > 85, c_x > pad_w && c_x < width + pad_w && c_y > pad_h && c_y < height + pad_h);
    }
    // Remove the map prototype
    free(map_prototype);
    // Allocate the map
    Map* map = malloc(sizeof(Map));
    map->tiles = tiles;
    map->tile_count = (uint)map_size;
    // Set map data values
    map->width = width;
    map->height = height;
    map->pad_h = pad_h;
    map->pad_w = pad_w;
    // Load the tileset textures
    SDL_Surface* bitmap_tileset = SDL_LoadBMP("assets/map/tiles.bmp");
    SDL_Surface* bitmap_tileset_border = SDL_LoadBMP("assets/map/tiles_border.bmp");
    map->tileset = SDL_CreateTextureFromSurface(renderer, bitmap_tileset);
    map->tileset_border = SDL_CreateTextureFromSurface(renderer, bitmap_tileset_border);
    SDL_SetTextureBlendMode(map->tileset, SDL_BLENDMODE_BLEND);
    SDL_SetTextureBlendMode(map->tileset_border, SDL_BLENDMODE_BLEND);
    // Free the bitmaps
    SDL_FreeSurface(bitmap_tileset);
    SDL_FreeSurface(bitmap_tileset_border);
    // Return the map
    return map;
  }
  // Destroy a map
  void destroyMap(Map* map) {
    // Free all tiles
    for (int i = 0; i < map->tile_count; i ++) {
      destroyTile(map->tiles[i]);
    }
    // Free the tile list and textures
    free(map->tiles);
    SDL_DestroyTexture(map->tileset);
    SDL_DestroyTexture(map->tileset_border);
    free(map);
  }

  // Render the map to the rect(where rect is usually whole screen) (TODO: will make the map fit the screen, treating padding as unimportant, can be given target bottom % to keep free for hand)
  void renderMap(SDL_Renderer* renderer, Map* map, SDL_Rect target, int bottom_padding) {
    // Determine padding
    int padding = target.w / 100; // 1%
    if (padding < 5) {
      padding = 5;
    }
    // Determine width and height of tile target rect
    int max_width = (int)((float)(target.w - 2*padding) / ((float)map->width + 24.0/32.0));
    int max_height = (int)((float)(target.h - 2*padding - target.h*bottom_padding/100) / ((float)map->height/2.0 + 0.5));
    SDL_Rect tile_target = {
      .w = 0,
      .h = 0,
      .x = 0,
      .y = 0,
    };
    // Note: 30.0 here since the actual tile-part is that height
    if (32.0/30.0 < (float)max_width / (float)max_height) {
      // Use max height as base
      tile_target.w = 32.0/48.0 * max_height;
      tile_target.h = max_height;
    } else {
      // Use max width as base
      tile_target.w = max_width;
      tile_target.h = 48.0/32.0 * max_width;
    }
    // Determine the tile hight (no decoration)
    int tile_height = tile_target.h * 28 / 48;
    // Determine padding needed top / bottom / left&right (does x2, since tiles are not square!)
    int padding_top = (padding / tile_height + 1) * 2;
    int padding_bottom = ((padding + target.h*bottom_padding/100) / tile_height + 1) * 2;
    int padding_side = (padding / tile_target.w + 1) * 2;
    // Determine the map origin (rel to map target)
    SDL_Point map_origin = {
      .x = target.x + (target.w - (tile_target.w * 16 / 32 + tile_target.w) * map->width) / 2,
      .y = target.y + padding,
    };
    // Render each tile
    int grid_width = padding_side * 2 + map->width;
    int grid_height = padding_top + padding_bottom + map->height;
    for (int i = 0; i < grid_width * grid_height; i ++) {
      // Set the render target position
      tile_target.x = map_origin.x + (tile_target.w * 15 / 32 + tile_target.w) * (i % grid_width - padding_side);
      tile_target.y = map_origin.y + tile_height * (i / grid_height - padding_top) / 2;
      // Shift every second row (rel to map-origin tile)
      if ((i / grid_height) % 2 != (padding_top - 1) % 2) {
        tile_target.x += tile_target.w * 24 / 32;
      }
      // Render the tile FIXME: Find actual tile
      if (i / grid_height >= padding_top && i / grid_height < grid_height - padding_bottom && i % grid_width >= padding_side && i % grid_width < grid_width - padding_side) {
        renderTile(map->tiles[1], map->tileset, renderer, &tile_target);
      } else {
        renderTile(map->tiles[8], map->tileset, renderer, &tile_target);
      }
    }
  }

  // Find map bottom space in coord units (find the space to the bottom NOT occupied by non_decoration tiles)
  int findMapBottomSpace(Map* map, SDL_Rect target, int bottom_padding) {
    return 1;
  }


  // Return is a road can be found that connects start->end
  int findMapRoad(Map* map, int start, int end, int length) {
    // FIXME
    return 1;
    int current_tile = start;
    for (int i = 0, j; i < length; i ++) {
      // Find next closer tile (cant go to neighbour 0 / 3)
      int closest_distance = -1;
      int closest_neighbour = -1;
      int neighbour = -1;
      int x_c,y_c,x_n,y_n,distance;
      for (j = 1; j < 6; j ++) {
        neighbour = findMapTileNeighbour(map, j, current_tile);
        if (j == 3 || neighbour == -1) {
          // TODO: Avoid water
          continue;
        }
        x_c = current_tile % map->width;
        x_n = neighbour % map->width;
        y_c = current_tile / map->width;
        y_n = neighbour / map->width;
        distance = (x_c-x_n)*(x_c-x_n) + (y_c-y_n)*(y_c-y_n)/4;
        if (closest_distance > distance || closest_distance < 0) {
          closest_distance = distance;
          closest_neighbour = neighbour;
        }
      }
      // Go to next tile
      current_tile = closest_neighbour;
      if (current_tile == end) {
        return 1;
      }
    }
    return 0;
  }
  // Create a road on the map (NOTE: Currently permanent!)
  int createMapRoad(Map* map, int start, int end, int length) {
    if (findMapRoad(map, start, end, length) == 0) {
      return 0;
    }
    int current_tile = start;
    int last_tile = start;
    for (int i = 0, j = 0; i < length; i ++) {
      // Find next closer tile (cant go to neighbour 0 / 3)
      int closest_distance = -1;
      int closest_neighbour = -1;
      int neighbour = -1;
      int x_c,y_c,x_n,y_n,distance;
      for (j = 1; j < 6; j ++) {
        neighbour = findMapTileNeighbour(map, j, current_tile);
        if (j == 3 || neighbour == last_tile || neighbour == -1) {
          // TODO: Avoid water
          continue;
        }
        // FIXME: This is a bad distance metric!
        x_c = current_tile % map->width;
        x_n = neighbour % map->width;
        y_c = current_tile / map->width;
        y_n = neighbour / map->width;
        distance = (x_c-x_n)*(x_c-x_n)*9/4 + (y_c-y_n)*(y_c-y_n)/4;
        if (closest_distance > distance || closest_distance == -1) {
          closest_distance = distance;
          closest_neighbour = neighbour;
        }
      }
      // Place road on current tile
      if (i > 0) {
        // FIXME: Place correct road
        map->roads[current_tile] = Cross;
      }
      // Go to next tile
      last_tile = current_tile;
      current_tile = closest_neighbour;
      if (current_tile == end) {
        return 1;
      }
    }
    // Should not be reached
    return 0;
  }
